# 复习

## node 的运行

- 直接再命令行输入 node 回车
  + 进入一个编辑状态
  + 我们直接写代码
- 把代码写再一个 js 文件里面
  + 打开命令行切换到 js 文件所在的目录
  + 使用 node 文件名

## node 的导入导出

- 导出
  + 每一个 js 文件都会默认导出 module.exports
  + 我们只要向这个对象中添加成员就会被导出
- 导入
  + 使用 require()
  + 导入一个文件，如果这个文件是 js 文件，那么不用写 后缀
  + 导入的时候接受返回值：
    + 就是你导入的那个文件里面导出的 module.exports

## node 的模块化

- 内置模块
  + node 自带的模块
- 自定义模块
  + 我们自己写的 js 文件
- 第三方模块
  + 别人写好的，我们下载来使用

## node 的内置模块 path

- 专门用来处理路径问题的
  + join() 方法，是用来拼接路径使用的

## node 的内置模块 fs

- 专门用来读写文件的
  + readFile(读取的路径，读取的格式，回调函数)
    + 读取的路径，如果没有这个文件就会报错
    + 读取的格式，可以不写，默认是 buffer 格式，我们可以写一个 'utf8'
    + 回调函数里面接受两个参数
      + err: 有错的时候就有内容，没有错误的时候就是 null
      + data: 有错误的时候，没有 data，没有错误的时候，data 就是你读取的文件里面的内容
  + writeFile(写入的路径，写入的内容，回调函数)
    + 写入的路径： 如果有这个文件，就向这个文件里面写入，如果没有这个文件，那么就创建一个文件写入内容
    + 写入的内容： 完全覆盖式的写入
    + 回调函数： 必须写，会在写入成功后执行
  + readFileSync(读取的路径，读取的格式)
    + 同步读取内容
    + 返回值： 就是读取的文件内容
    + 如果出错的时候，直接报错，中断程序继续执行
  + writeFileSync(写入的路径，写入的内容)
    + 同步写入内容
    + 完全覆盖式的写入

## node 的内置模块 http

- 专门用来开启一个服务的
  + createServer(回调函数)
    + 返回值就是这个服务
    + 回调函数，每一个请求进来的时候都会执行
      + 有两个形参
      + req: request,表示当前请求
      + res: response,表示对当前请求的响应
  + listen(端口号，回调函数)
    + 用来监听一个端口号
    + 端口号： 0 ~ 65535（我们自己写的时候，尽量不要用 0 ~ 1024）
    + 回调函数： 会在监听成功的时候执行

## node 的后端路由

- 根据不同的前端请求给出不同的响应

## npm

- 是一个包管理器
  + 专门帮我们下载和管理包的一个工具
- 下载
  + npm install 包名
    + npm i 包名
  + npm i 包名@版本号
  + 下载的时候，如果你有一个之前的版本，又下载另一个版本，会发生替换
- 初始化
  + npm init
    + 会进入一个编辑状态，让你进行选择
  + npm init -y
    + 会直接生成 package.json 文件
    + 所有的选项全部都是默认值
      + 因为项目名称会自动使用文件夹名称，不要把文件夹写成中文
- npm 卸载
  + npm uninstall 包名
    + 不需要加版本号
- package.json
  + 又一个模块是用来记录你的所有安装的依赖项
  + 直接使用 npm i 这个指令就可以下载全部的依赖项
- npm 清除缓存
  + 指令
    + npm cache clear -f
    + npm cache clean -f
  + 手动
    + C:users/你的名字/AppData/roaming
    + 再这个文件夹里面找到 npm-cache 直接删除

- nrm
  + 是一个管理 npm 镜像源地址的工具
  + 需要使用 npm 进行安装
  + 安装成全局包就行了
    + npm i -g nrm
  + nrm test
    + 检测所有的可用镜像源地址的网络延迟
  + nrm use 地址名称
    + 切换 npm 的镜像源地址

# 上午复习

## sass

- 是一个 css 的预编译工具
- 使用 npm 安装一个 sass 全局包
  + `$ npm i -g sass`

## sass 两种文件的区别

- .sass
  + 书写的时候没有 {} 和 ;
- .scss
  + 和普通的 css 书写一样

## sass 编译

### 单文件编译

- 使用指令的方式
  + `sass 你要编译的文件 生成的文件`
- 编译完毕每次修改都要从新编译

### 实时单文件编译

- 使用指令的方式
  + `sass --watch 你要编译的文件:生成的文件`
- 对源文件的每一次修改都会自动重新编译
  + 只能监控一个文件的变化

### 实时文件夹编译

- 使用指令的方式
  + `sass --watch 你要编译的文件夹:生成的文件夹`
- 对你要编译的文件夹进行监控
  + 只要这个文件夹里面的 `.scss` 和 `.sass` 只要发生变化
  + 就会生成最新的 css 文件放在你指定的文件夹里面

## sass 语法

### 注释

- `//` 普通单行注释，会在编译的时候就消失了
- `/**/` 普通多行注释，编译的时候会保留，打包的时候就消失
- `/*!*/` 强力注释，编译的时候会保留，打包的时候也会保留

### 变量

- 直接使用 `$变量名: 值;`
- 使用变量的时候直接使用 `$变量名`

### 嵌套

- 在一个规则集里面书写另一个规则集

1. 普通嵌套
  ```scss
    div {

      p {

      }
    }

    // 编译结果
    div {}
    div p {}
  ```
2. 子代选择器嵌套
  ```scss
    div {

      > p {

      }
    }

    // 编译结果
    div {}
    div > p {}
  ```
3. & 链接嵌套
  ```scss
    div {

      &:hover {

      }
    }

    // 编译结果
    div {}
    div:hover {}
  ```
4. 群组嵌套
  + 一个嵌套多个
  ```scss
    div {

      .box1, .box2 {}
    }

    // 编译结果
    div {}
    div .box1, div .box2 {}
  ```
  + 多个嵌套一个
  ```scss
    .box1, .box2 {

      div {}
    }

    .box1, .box2{}
    .box1 div, .box2 div {}
  ```
  + 多个嵌套多个
  ```scss
    .box1, .box2 {

      div, p {

      }
    }

    // 编译结果
    .box1, .box2 {}
    .box1 div, .box2 div, .box1 p, .box2 p {}
  ```
5. 属性嵌套
  + 前提是属性要有 - 才可以
  ```scss
    div {
      margin: {
        top: 10px;
        left: 10px;
        right: 10px;
        bottom: 20px;
      };
    }

    // 编译结果
    div {
      margin-top: 10px;
      margin-left: 10px;
      margin-right: 10px;
      margin-bottom: 20px;
    }
  ```
  ```scss
    div {
      margin: 10px {
        left: 20px;
      };
    }

    // 编译结果
    div {
      margin: 10px;
      margin-left: 20px;
    }
  ```
