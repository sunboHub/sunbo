<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <!--
    git 的使用
      + 安装完毕以后进行一个全局配置
      + 当你上传的时候，远程要知道是谁在上传
      + 配置一下我自己的邮箱和用户名
      + 直接打开 命令行 或者 git base here
        + `$ git config --list ` 查看你目前的配置列表
        + `$ git config --global user.name "你的用户名"`
        + `$ git config --global user.email "你的邮箱"`

    git 管理文件夹
      + git 不会随便管理你的文件夹
      + 我们需要告诉他这个文件夹由 git 管理，他才会帮你管理整个文件夹
      + 有一个指令，叫做 git 初始化
        + `$ git init`
        + 告诉 git，这个文件夹及所有子目录都被 git 管理了
      + 当一个文件夹被 git 管理以后，我们就可以使用一些 git 的指令来操作文件了

    git 的常用指令
      + 当一个文件夹被 git 管理以后
      + 会自动分成三个区域
        + 开发的区域
        + 暂存区： 暂时存储
        + 历史区： 生成一个历史版本的地方
      + 想形成一个历史版本
        + 只能把 暂存区的所有内容生成一个历史版本
      + 想上传到 github，只能上传历史区的所有内容
      + `$ git status`
        + 查看当前文件夹内部的所有文件的状态
      + `$ git log`
        + 查看历史区的所有版本
        +
          当前你这个版本的版本 id
          commit 3837544e6268f68c477453dec9dc5f76fbc8f935 (HEAD -> master)
          作者
          Author: WDBBdpd223322 <35942877+WDBBdpd223322@users.noreply.github.com>
          时间
          Date:   Tue Oct 8 11:45:58 2019 +0800

              这个是我的第一个版本

    把文件放在暂存区保存
      + `git add xxx`
        + `$ git add 文件名` 把一个文件添加到暂存区
        + `$ git add 文件夹名称/` 把一个文件夹添加到暂存区
        + `$ git add --all` 所有内容添加到暂存区
        + `$ git add .` 所有内容添加到暂存区

    把暂存区里面的东西拉回到开发区域
      + `git reset HEAD -- xxx`
        + `$ git reset HEAD -- 文件名`
        + `$ git reset HEAD -- 文件夹名称/`
        + `$ git reset HEAD -- .` 拉回所有内容

    把暂存区的内容形成一个历史版本
      + `git commit -m "对本次历史版本做一个说明"`
      + 这个指令会把暂存区内所有的东西形成一个历史版本放在历史区里面保留
      + 一旦形成历史版本以后，暂存区里面就没有东西了

    跳转到某一个历史版本
      + 需要的是一个 版本 id
      + `$ git reset --hard 版本 id`

    上传到远程仓库
      + 你得有一个远程仓库
      + 告诉你的 git 你要上传到哪一个 github 仓库
      + `git remote add origin 你的仓库地址`
        + git 使用指令
        + remote 远程
        + add 添加
        + origin 变量名（值： 你的仓库地址）
        + 你的仓库地址： github 上的那个仓库地址
      + 就是直接推送到远端就可以了
        + `git push -u origin master`

    克隆一个远程仓库
      + 克隆你自己的仓库
      + 克隆别人的仓库
      + 你克隆下来的仓库是由 git 配置信息的
        + 克隆的是自己的仓库，那么可以继续上传
        + 克隆的是别人的仓库，当你再次上传的时候就要用户名和密码
      + `$ git clone 你要克隆的地址` 就可以了
      + 会把远程仓库内部的所有内容给你当作一个文件夹下载下来
        + 文件夹的名称就是你远程仓库的名称
        + 内容就是仓库里面的内容

    拉取远程仓库代码
      + 当你这个文件夹被 git 管理以后
      + 会存在一个 .git 的文件夹
      + 当他和远程链接以后，这个文件夹里面的 config 文件里会有一个远程仓库的信息
      + 如果你的文件夹是从远程克隆下来的
        + 直接就会有一个 .git 的文件夹，里面就会有一个 config 的配置文件
        + 在里面记录着远程的信息
      + 拉取代码就是从这个远程信息位置的仓库
        + 把最新的代码拉取回来
      + `git pull`

    git 的分支
      + 对于我的独立功能单独开辟一个分支进行操作
      + 当你的文件夹被 git 管理以后，会自动创建一个叫做 master 的分支
      + 当我需要做某一个功能的时候，我会创建一个新的分支来进行开发
        + 在开发完毕以后，会把这个分支上的内容合并到 master 分支上
      + 常用的分支名称
        + master 主要分支： 主项目分支
          + 只存在可以向外发布的完整版代码
        + develop 主开发分支： 存储项目所有代码
          + 只存放一经开发完毕的代码
        + feature-xxx 主功能分支
          + 一个一个的功能
        + feature-xxx-fix 解决 bug 的分支
          + 用来进行 bug 修复
        + hotfix-xxx 临时解决问题的分支
          + 当上线运行的项目出现问题了
      + git 分支的指令
        + `$ git branch` 查看当前分支
        + `$ git branch 分支名称` 创建一个新的分支
          + 你在哪一个分支上创建的新分支
          + 新分支上的内容就是哪一个分支上的内容
        + `$ git checkout 分支名称` 切换分支
      + 进行分支合并
        + 你站在某一个分支上，把别的分支的内容合并到自己身上
        + `$ git merge 你要合并的分支名称`

    git 冲突
      + 多人异地向一个分支内提交代码

    git 两个相关的文件
      + .gitignore
        + 没有名称只有后缀
        + 当你使用 git add . 把所有的内容都添加到暂存区
        + .gitignore 里面记录的文件或者文件夹不添加
        + 一般至少会写一个 node_modules
      + .gitkeep
        + 因为 git 不能上传一个空文件夹
        + 这个文件就是为了保留文件夹使用的
  -->
</body>
</html>
